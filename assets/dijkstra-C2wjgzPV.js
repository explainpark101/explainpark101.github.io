import{D as e,E as t,O as n,S as r,T as i,_ as a,b as o,f as s,h as c,l,n as u,o as d,r as f,t as p,v as m,w as h}from"./index-D0aBWOAh.js";import{t as g}from"./_plugin-vue_export-helper-9n1O4nl6.js";var _={class:`dijkstra-app`},v={class:`container-fluid`},y={class:`container`},b={for:`undirected`},x=[`innerHTML`],S=g({__name:`index`,setup(g){let S=p(),C=u(),w=n(``),T=n(``),E=n(``),D=n(``),O=n(!0),k=n(``),A=n(null);function j(e,t,n){let r=Object.keys(e),i={},a={},o=new Set(r);r.forEach(e=>{i[e]=1/0,a[e]=null}),i[t]=0;let s=``,c=[],l=1;for(;o.size>0;){let t=null;if(o.forEach(e=>{(t===null||i[e]<i[t])&&(t=e)}),i[t]===1/0)break;for(let n in o.delete(t),s+=`<strong>Iteration ${l}:</strong> 현재 노드: ${t} (거리: ${i[t]})<br>`,e[t])if(o.has(n)){let r=i[t]+e[t][n];r<i[n]&&(i[n]=r,a[n]=t,s+=`&emsp; 업데이트: ${n}의 새로운 거리: ${r} (이전 노드: ${t})<br>`)}c.push({iteration:l,currentNode:t,distances:Object.assign({},i)}),l++}let u=[],d=n;if(a[d]!==null||d===t)for(;d;)u.unshift(d),d=a[d];return{path:u,distances:i,processLog:s,iterationRecords:c}}function M(e,t){if(e.length===0)return``;let n=`<table>`;return n+=`<tr>`,n+=`<th>Iteration</th>`,n+=`<th>Current Node</th>`,t.forEach(e=>{n+=`<th>${e}</th>`}),n+=`</tr>`,e.forEach(e=>{n+=`<tr>`,n+=`<td>${e.iteration}</td>`,n+=`<td>${e.currentNode}</td>`,t.forEach(t=>{let r=e.distances[t];n+=`<td>${r===1/0?`∞`:r}</td>`}),n+=`</tr>`}),n+=`</table>`,n}function N(e,t,n){if(!window.vis||!A.value)return;let r=e.map(e=>({id:e,label:e})),i=[],a=new Set;for(let e in t)for(let r in t[e]){let o=n?[e,r].sort().join(`-`):[e,r].join(`-`);a.has(o)||(a.add(o),i.push({from:e,to:r,label:String(t[e][r])}))}let o=n?{arrows:{to:{enabled:!0,scaleFactor:1},from:{enabled:!0,scaleFactor:1}}}:{arrows:{to:{enabled:!0,scaleFactor:1}}},s={nodes:r,edges:i},c={layout:{hierarchical:!1},physics:{stabilization:!1},edges:Object.assign({font:{align:`middle`}},o)};new vis.Network(A.value,s,c)}function P(){let e=w.value.trim(),t=T.value.trim(),n=E.value.trim(),r=D.value.trim(),i=e.split(`,`).map(e=>e.trim()),a={};i.forEach(e=>{a[e]={}}),t.split(`
`).forEach(e=>{let t=e.split(/,|\|/).map(e=>e.trim());if(t.length<3)return;let n=t[0],r=t[1],i=parseFloat(t[2]);a[n][r]=i,O.value&&(a[r][n]=i)}),N(i,a,O.value);let{path:o,distances:s,processLog:c,iterationRecords:l}=j(a,n,r);if(o.length===0||s[r]===1/0)k.value=`<p>경로를 찾을 수 없습니다.</p>`;else{let e=``;e+=`<h3>최단 경로</h3><p>${o.join(` -> `)}</p>`,e+=`<h3>총 거리</h3><p>${s[r]}</p>`,e+=`<h3>Iteration별 Node Cost</h3>`,e+=M(l,i),e+=`<h3>계산 과정 (Log)</h3><p>${c}</p>`,k.value=e}F()}function F(){C.replace({query:{nodes:w.value,edges:T.value,start:E.value,end:D.value,undirected:O.value}})}return i([w,T,E,D,O],()=>{F()}),o(()=>{if(!document.querySelector(`link[href*="picocss"]`)){let e=document.createElement(`link`);e.rel=`stylesheet`,e.href=`https://unpkg.com/@picocss/pico@latest/css/pico.min.css`,document.head.appendChild(e)}if(window.vis){let e=S.query;e.nodes&&e.edges&&e.start&&e.end&&(w.value=e.nodes,T.value=e.edges,E.value=e.start,D.value=e.end,O.value=e.undirected===`true`||e.undirected===!0,P())}else{let e=document.createElement(`script`);e.src=`https://unpkg.com/vis-network/standalone/umd/vis-network.min.js`,e.onload=()=>{let e=S.query;e.nodes&&e.edges&&e.start&&e.end&&(w.value=e.nodes,T.value=e.edges,E.value=e.start,D.value=e.end,O.value=e.undirected===`true`||e.undirected===!0,P())},document.head.appendChild(e)}}),(n,i)=>{let o=h(`router-link`);return r(),c(`div`,_,[s(`nav`,v,[s(`ul`,null,[s(`li`,null,[m(o,{to:`/`,style:{display:`inline-flex`,"align-items":`center`,gap:`0.5rem`,"font-size":`1.2rem`}},{default:t(()=>[...i[5]||=[s(`span`,{class:`material-icons`,style:{"font-size":`1.5rem`}},`home`,-1)]]),_:1})])])]),s(`main`,y,[i[21]||=s(`h1`,null,`Dijkstra 알고리즘 계산기`,-1),i[22]||=s(`p`,null,[a(` 다익스트라 알고리즘은 가중치가 있는 그래프에서 한 노드로부터 다른 노드까지의 최단 경로를 찾는 알고리즘입니다.`),s(`br`),a(` 각 Iteration마다 노드까지의 비용이 어떻게 변화하는지 표와 로그로 확인할 수 있으며, 입력한 데이터로 구성된 그래프를 시각적으로도 볼 수 있습니다. `)],-1),s(`form`,{onSubmit:l(P,[`prevent`])},[i[7]||=s(`label`,{for:`nodes`},`노드 정보 (예: A,B,C,D):`,-1),i[8]||=s(`br`,null,null,-1),e(s(`input`,{type:`text`,id:`nodes`,"onUpdate:modelValue":i[0]||=e=>w.value=e,placeholder:`A,B,C,D`,required:``},null,512),[[d,w.value]]),i[9]||=s(`br`,null,null,-1),i[10]||=s(`label`,{for:`edges`},`링크 정보 (예: A,B,3 A,C,5 B,C,2 C,D,1):`,-1),i[11]||=s(`br`,null,null,-1),e(s(`textarea`,{id:`edges`,"onUpdate:modelValue":i[1]||=e=>T.value=e,placeholder:`A,B,3
A,C,5
B,C,2
C,D,1`,required:``},null,512),[[d,T.value]]),i[12]||=s(`br`,null,null,-1),i[13]||=s(`label`,{for:`start`},`시작 노드:`,-1),i[14]||=s(`br`,null,null,-1),e(s(`input`,{type:`text`,id:`start`,"onUpdate:modelValue":i[2]||=e=>E.value=e,placeholder:`A`,required:``},null,512),[[d,E.value]]),i[15]||=s(`br`,null,null,-1),i[16]||=s(`label`,{for:`end`},`도착 노드:`,-1),i[17]||=s(`br`,null,null,-1),e(s(`input`,{type:`text`,id:`end`,"onUpdate:modelValue":i[3]||=e=>D.value=e,placeholder:`D`,required:``},null,512),[[d,D.value]]),i[18]||=s(`br`,null,null,-1),s(`label`,b,[e(s(`input`,{type:`checkbox`,id:`undirected`,"onUpdate:modelValue":i[4]||=e=>O.value=e},null,512),[[f,O.value]]),i[6]||=a(` 양방향 링크 (체크 시 양방향, 해제 시 단방향) `,-1)]),i[19]||=s(`br`,null,null,-1),i[20]||=s(`button`,{type:`submit`},`최단 경로 계산`,-1)],32),s(`div`,{id:`graph`,ref_key:`graphContainer`,ref:A},null,512),s(`div`,{class:`result`,innerHTML:k.value},null,8,x)])])}}},[[`__scopeId`,`data-v-753d2beb`]]);export{S as default};