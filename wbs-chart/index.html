<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WBS 계층 구조 차트 (D3.js)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- D3.js 라이브러리를 추가합니다. -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden; /* 전체 화면 사용 시 스크롤바 제거 */
            font-family: 'Inter', sans-serif;
        }
        #chart-container {
            width: 100%;
            height: 100%;
            background-color: #f7fafc; /* bg-gray-100 */
        }
        /* D3.js 차트 스타일링 */
        .node rect {
            stroke-width: 2px;
            cursor: pointer;
            transition: stroke 0.3s, stroke-width 0.3s;
        }
        .node rect.selected {
            stroke: #3182CE; /* blue-500 */
            stroke-width: 3px;
        }
        .node text {
            font-family: 'Inter', sans-serif;
            font-size: 13px;
            fill: #2D3748; /* gray-800 */
            pointer-events: none; /* 텍스트가 rect의 이벤트를 가리지 않도록 설정 */
        }
        .link {
            fill: none;
            stroke: #CBD5E0; /* gray-400 */
            stroke-width: 1.5px;
        }
    </style>
</head>
<body>
    <!-- 편집 툴바 -->
    <div id="edit-toolbar" class="hidden absolute top-0 left-0 h-full w-80 bg-white shadow-xl z-20 p-6 transform -translate-x-full transition-transform duration-300 overflow-y-auto">
        <div class="flex justify-between items-center mb-6">
            <h2 class="text-xl font-bold text-gray-800">노드 편집</h2>
            <button id="close-toolbar-btn" class="text-gray-500 hover:text-gray-800">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        </div>
        <div class="space-y-4">
            <div>
                <label for="node-name-input" class="block text-sm font-medium text-gray-700">노드 이름</label>
                <textarea id="node-name-input" rows="3" class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm"></textarea>
            </div>
            <div>
                <label for="node-parent-select" class="block text-sm font-medium text-gray-700">부모 노드 변경</label>
                <select id="node-parent-select" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md"></select>
            </div>
        </div>
        <div class="mt-8 space-y-3">
            <button id="save-changes-btn" class="w-full bg-blue-600 text-white py-2 px-4 rounded-md hover:bg-blue-700 transition-colors">변경 사항 저장</button>
            <button id="add-child-btn" class="w-full bg-green-600 text-white py-2 px-4 rounded-md hover:bg-green-700 transition-colors">자식 노드 추가</button>
            <button id="add-sibling-btn" class="w-full bg-indigo-600 text-white py-2 px-4 rounded-md hover:bg-indigo-700 transition-colors">형제 노드 추가</button>
            <button id="delete-node-btn" class="w-full bg-red-600 text-white py-2 px-4 rounded-md hover:bg-red-700 transition-colors">노드 삭제</button>
        </div>
    </div>

    <!-- 툴바 -->
    <div id="toolbar" class="absolute top-4 right-4 z-10 flex space-x-2">
         <!-- JSON Import Button -->
        <button id="import-json-btn" class="bg-white hover:bg-gray-100 text-gray-700 font-semibold py-2 px-4 border border-gray-300 rounded-lg shadow-md flex items-center transition-colors duration-200">
            <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"></path></svg>
            <span>불러오기</span>
        </button>
        <!-- JSON Export Button -->
        <button id="export-json-btn" class="bg-white hover:bg-gray-100 text-gray-700 font-semibold py-2 px-4 border border-gray-300 rounded-lg shadow-md flex items-center transition-colors duration-200">
             <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path></svg>
            <span>내보내기</span>
        </button>
        <!-- PNG Export Button -->
        <button id="export-png-btn" class="bg-white hover:bg-gray-100 text-gray-700 font-semibold py-2 px-4 border border-gray-300 rounded-lg shadow-md flex items-center transition-colors duration-200">
            <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"></path></svg>
            <span>PNG로 저장</span>
        </button>
    </div>

    <!-- D3.js가 SVG 차트를 렌더링할 컨테이너 -->
    <div id="chart-container"></div>

    <!-- Custom Modal -->
    <div id="custom-modal-overlay" class="hidden fixed inset-0 bg-gray-600 bg-opacity-50 z-30 flex items-center justify-center">
        <div id="custom-modal" class="bg-white rounded-lg shadow-xl p-6 w-full max-w-md">
            <h3 id="modal-title" class="text-lg font-bold text-gray-900 mb-4">Modal Title</h3>
            <p id="modal-message" class="text-sm text-gray-600 mb-4"></p>
            <input id="modal-input" type="text" class="hidden w-full border border-gray-300 rounded-md shadow-sm p-2 mb-4" />
            <div class="flex justify-end space-x-3">
                <button id="modal-cancel-btn" class="bg-gray-200 text-gray-800 py-2 px-4 rounded-md hover:bg-gray-300 transition-colors">취소</button>
                <button id="modal-ok-btn" class="bg-blue-600 text-white py-2 px-4 rounded-md hover:bg-blue-700 transition-colors">확인</button>
            </div>
        </div>
    </div>

    <script>
        // 전역 변수
        let hierarchicalData;
        let selectedNode = null;
        const svg = d3.select("#chart-container").append("svg").attr("width", "100%").attr("height", "100%");
        const g = svg.append("g");
        const LOCAL_STORAGE_KEY = 'wbsChartData';

        // 1. 데이터 계층 구조로 변환 (ID 추가)
        function initializeData() {
            hierarchicalData = { name: "새 프로젝트", id: crypto.randomUUID(), children: [] };
        }

        // --- LocalStorage Functions ---
        function saveDataToLocalStorage() {
            if (hierarchicalData) {
                localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(hierarchicalData));
            }
        }

        function loadDataFromLocalStorage() {
            const savedData = localStorage.getItem(LOCAL_STORAGE_KEY);
            if (savedData) {
                hierarchicalData = JSON.parse(savedData);
                return true;
            }
            return false;
        }

        // 2. 차트 렌더링/업데이트 함수
        function updateChart() {
            g.selectAll('*').remove(); // 기존 차트 지우기

            const nodeWidth = 200;
            const nodeHeight = 60;
            const root = d3.hierarchy(hierarchicalData, d => d.children);

            // 수동 레이아웃 계산 (Trunk and Branch 스타일)
            const horizontalGap = nodeWidth + 150;
            const verticalGap = nodeHeight + 40;
            const levelGap = 150;
            const branchOffset = 130;

            root.x = 0;
            root.y = 0;

            if (root.children) {
                const numPhases = root.children.length;
                const totalWidth = (numPhases - 1) * horizontalGap;
                const startX = -totalWidth / 2;

                root.children.forEach((phaseNode, i) => {
                    phaseNode.x = startX + i * horizontalGap;
                    phaseNode.y = root.y + levelGap;
                    if (phaseNode.children) {
                        phaseNode.children.forEach((taskNode, j) => {
                            taskNode.y = phaseNode.y + levelGap * 0.8 + j * verticalGap;
                            taskNode.x = phaseNode.x + branchOffset;
                        });
                    }
                });
            }

            const links = root.links();
            const nodes = root.descendants();

            g.selectAll(".link")
                .data(links).enter().append("path")
                .attr("class", "link")
                .attr("d", d => {
                    if (d.source.depth === 0) {
                        return `M ${d.source.x},${d.source.y + nodeHeight / 2}` +
                               `L ${d.target.x},${d.target.y - nodeHeight / 2}`;
                    }
                    const sourceX = d.source.x;
                    const sourceY = d.source.y + nodeHeight / 2;
                    const targetX = d.target.x - nodeWidth / 2;
                    const targetY = d.target.y;
                    return `M ${sourceX},${sourceY} V ${targetY} H ${targetX}`;
                });

            const node = g.selectAll(".node")
                .data(nodes).enter().append("g")
                .attr("class", "node")
                .attr("transform", d => `translate(${d.x},${d.y})`)
                .on('click', (event, d) => {
                    g.selectAll('rect.selected').classed('selected', false);
                    d3.select(event.currentTarget).select('rect').classed('selected', true);
                    selectedNode = d;
                    showEditToolbar(d);
                });

            node.append("rect")
                .attr("width", nodeWidth).attr("height", nodeHeight)
                .attr("x", -nodeWidth / 2).attr("y", -nodeHeight / 2)
                .attr("rx", 5)
                .style("fill", d => (d.depth === 0 ? "#E2E8F0" : d.children ? "#F1F5F9" : "#FFFFFF"))
                .style("stroke", d => (d.depth === 0 ? "#4A5568" : "#A0AEC0"))
                .classed('selected', d => d.data.id === selectedNode?.data.id);

            node.append("text")
                .style("text-anchor", "middle")
                .text(d => d.data.name)
                .call(wrap, nodeWidth - 20);
        }

        // 3. 툴바 관련 함수들
        const toolbarEl = document.getElementById('edit-toolbar');
        const nameInput = document.getElementById('node-name-input');
        const parentSelect = document.getElementById('node-parent-select');

        function showEditToolbar(node) {
            nameInput.value = node.data.name;
            populateParentSelect(parentSelect, node, hierarchicalData);

            const addChildBtn = document.getElementById('add-child-btn');
            const addSiblingBtn = document.getElementById('add-sibling-btn');
            const deleteNodeBtn = document.getElementById('delete-node-btn');

            const isRoot = node.depth === 0;
            const isTaskOrLower = node.depth >= 2;

            // 계층에 따라 버튼 보이기/숨기기
            addSiblingBtn.classList.toggle('hidden', isRoot); // 0계층이면 형제 추가 숨김
            addChildBtn.classList.toggle('hidden', isTaskOrLower); // 2계층 이상이면 자식 추가 숨김

            // 계층에 따라 버튼 활성화/비활성화
            deleteNodeBtn.disabled = isRoot;
            parentSelect.disabled = isRoot;

            toolbarEl.classList.remove('hidden', '-translate-x-full');
            nameInput.focus();
        }

        function hideEditToolbar() {
            toolbarEl.classList.add('-translate-x-full');
            setTimeout(() => toolbarEl.classList.add('hidden'), 300);
            g.selectAll('rect.selected').classed('selected', false);
            selectedNode = null;
        }

        function populateParentSelect(selectEl, node, rootData) {
            selectEl.innerHTML = '';
            const descendants = new Set();
            function getDescendantIds(d) {
                descendants.add(d.id);
                if (d.children) d.children.forEach(getDescendantIds);
            }
            getDescendantIds(node.data);

            function buildOptions(d, depth = 0) {
                if (descendants.has(d.id)) return;
                const option = document.createElement('option');
                option.value = d.id;
                option.textContent = '—'.repeat(depth) + ' ' + d.name;
                const currentParent = findParentOfNode(rootData, node.data.id);
                if (currentParent && currentParent.id === d.id) option.selected = true;
                selectEl.appendChild(option);

                if (d.children) d.children.forEach(child => buildOptions(child, depth + 1));
            }
            buildOptions(rootData);
        }

        // 4. 이벤트 리스너 설정
        document.getElementById('close-toolbar-btn').addEventListener('click', hideEditToolbar);

        document.getElementById('save-changes-btn').addEventListener('click', () => {
            if (!selectedNode) return;
            const nodeData = findNodeById(hierarchicalData, selectedNode.data.id);
            if (!nodeData) return;

            nodeData.name = nameInput.value;

            const newParentId = parentSelect.value;
            const oldParent = findParentOfNode(hierarchicalData, nodeData.id);
            if (oldParent && oldParent.id !== newParentId) {
                const newParent = findNodeById(hierarchicalData, newParentId);
                if (newParent) {
                    oldParent.children = oldParent.children.filter(child => child.id !== nodeData.id);
                    if (!newParent.children) newParent.children = [];
                    newParent.children.push(nodeData);
                }
            }
            updateChart();
            saveDataToLocalStorage();
        });
        document.getElementById('node-name-input').addEventListener('keydown', (event) => {
            if (event.ctrlKey && event.key === 'Enter') {
                document.getElementById('save-changes-btn').click();
            }
            if (event.key === 'Escape') {
                document.getElementById('close-toolbar-btn').click();
            }
        });

        document.getElementById('add-child-btn').addEventListener('click', async () => {
            if (!selectedNode) return;
            const childName = await showModal("자식 노드 추가", "새 자식 노드의 이름을 입력하세요:", true, "");
            if (childName) {
                const nodeData = findNodeById(hierarchicalData, selectedNode.data.id);
                if (!nodeData.children) nodeData.children = [];
                nodeData.children.push({ name: childName, id: crypto.randomUUID() });
                updateChart();
                saveDataToLocalStorage();
            }
        });

        document.getElementById('add-sibling-btn').addEventListener('click', async () => {
            if (!selectedNode) return;
            const parent = findParentOfNode(hierarchicalData, selectedNode.data.id);
            if (!parent) {
                await showModal("오류", "루트 노드에는 형제 노드를 추가할 수 없습니다.");
                return;
            }
            const siblingName = await showModal("형제 노드 추가", "새 형제 노드의 이름을 입력하세요:", true, "");
            if (siblingName) {
                const newNode = { name: siblingName, id: crypto.randomUUID() };
                const selectedNodeIndex = parent.children.findIndex(child => child.id === selectedNode.data.id);
                if (selectedNodeIndex > -1) {
                    parent.children.splice(selectedNodeIndex + 1, 0, newNode);
                }
                updateChart();
                saveDataToLocalStorage();
            }
        });

        document.getElementById('delete-node-btn').addEventListener('click', async () => {
            if (!selectedNode) return;
            const confirmed = await showModal("노드 삭제", `'${selectedNode.data.name}' 노드를 정말 삭제하시겠습니까? 모든 자식 노드도 함께 삭제됩니다.`);
            if (confirmed) {
                const parent = findParentOfNode(hierarchicalData, selectedNode.data.id);
                if (parent) {
                    parent.children = parent.children.filter(child => child.id !== selectedNode.data.id);
                    hideEditToolbar();
                    updateChart();
                    saveDataToLocalStorage();
                } else {
                    await showModal("오류", "루트 노드는 삭제할 수 없습니다.");
                }
            }
        });

        // 5. 유틸리티 함수들 (줌/패닝, PNG/JSON 저장, 모달)
        const zoom = d3.zoom().scaleExtent([0.1, 3]).on("zoom", (event) => g.attr("transform", event.transform));
        svg.call(zoom);

        document.getElementById('export-png-btn').addEventListener('click', () => {
            const wasToolbarVisible = !toolbarEl.classList.contains('hidden');
            if(wasToolbarVisible) hideEditToolbar();

            setTimeout(() => {
                const svgEl = svg.node();
                const gBounds = g.node().getBBox();
                const padding = 50;
                const width = gBounds.width + padding * 2;
                const height = gBounds.height + padding * 2;
                const svgString = getSVGString(svgEl, gBounds, padding);

                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');
                const img = new Image();
                img.onload = function() {
                    ctx.fillStyle = '#f7fafc';
                    ctx.fillRect(0, 0, width, height);
                    ctx.drawImage(img, 0, 0);
                    const a = document.createElement('a');
                    a.download = 'wbs-chart.png';
                    a.href = canvas.toDataURL('image/png');
                    a.click();
                    if(wasToolbarVisible) showEditToolbar(selectedNode);
                };
                img.src = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svgString)));
            }, 350);
        });

        document.getElementById('export-json-btn').addEventListener('click', () => {
            const jsonString = JSON.stringify(hierarchicalData, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'wbs-data.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });

        document.getElementById('import-json-btn').addEventListener('click', () => {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json,application/json';
            input.onchange = e => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = async readerEvent => {
                    try {
                        const content = readerEvent.target.result;
                        const jsonData = JSON.parse(content);

                        if (jsonData.name && jsonData.id) {
                            hierarchicalData = jsonData;
                            hideEditToolbar();
                            updateChart();
                            saveDataToLocalStorage();
                            await showModal("성공", "JSON 데이터를 성공적으로 불러왔습니다.");
                        } else {
                            throw new Error("Invalid JSON format. Missing 'name' or 'id' property.");
                        }
                    } catch (error) {
                        console.error("Error parsing JSON:", error);
                        await showModal("오류", "JSON 파일을 불러오는 중 오류가 발생했습니다. 파일 형식을 확인해주세요.");
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        });

        // --- Modal Logic ---
        const modalOverlay = document.getElementById('custom-modal-overlay');
        const modalTitle = document.getElementById('modal-title');
        const modalMessage = document.getElementById('modal-message');
        const modalInput = document.getElementById('modal-input');
        const modalOkBtn = document.getElementById('modal-ok-btn');
        const modalCancelBtn = document.getElementById('modal-cancel-btn');

        let modalResolve = null;

        function showModal(title, message = '', showInput = false, placeholder = '') {
            modalTitle.textContent = title;
            modalMessage.textContent = message;

            if (showInput) {
                modalInput.value = placeholder;
                modalInput.classList.remove('hidden');
                modalInput.focus();
            } else {
                modalInput.classList.add('hidden');
            }

            modalOverlay.classList.remove('hidden');
            if (showInput) modalInput.focus();

            return new Promise(resolve => {
                modalResolve = resolve;
            });
        }

        modalOkBtn.addEventListener('click', () => {
            if (modalResolve) {
                modalOverlay.classList.add('hidden');
                const value = modalInput.classList.contains('hidden') ? true : modalInput.value;
                modalResolve(value);
                modalResolve = null;
            }
        });

        modalCancelBtn.addEventListener('click', () => {
            if (modalResolve) {
                modalOverlay.classList.add('hidden');
                const value = modalInput.classList.contains('hidden') ? false : null;
                modalResolve(value);
                modalResolve = null;
            }
        });

        modalInput.addEventListener('keydown', (event) => {
            if (event.key === 'Enter') {
                modalOkBtn.click();
            }
            if (event.key === 'Escape') {
                modalCancelBtn.click();
            }
        });

        // 초기화
        window.onload = () => {
            if (!loadDataFromLocalStorage()) {
                initializeData();
            }

            updateChart();
            const bounds = g.node().getBBox();
            const parent = svg.node().parentElement;
            const fullWidth = parent.clientWidth;
            const fullHeight = parent.clientHeight;
            const scale = 0.6;
            const initialX = fullWidth / 2 - (bounds.x + bounds.width / 2) * scale;
            const initialY = 100;
            const initialTransform = d3.zoomIdentity.translate(initialX, initialY).scale(scale);
            svg.call(zoom.transform, initialTransform);
        };

        // --- Helper function implementations ---
        function findNodeById(node, id) {
            if (node.id === id) return node;
            if (node.children) {
                for (const child of node.children) {
                    const found = findNodeById(child, id);
                    if (found) return found;
                }
            }
            return null;
        }

        function findParentOfNode(parent, childId) {
            if (!parent.children) return null;
            for (const child of parent.children) {
                if (child.id === childId) return parent;
                const foundParent = findParentOfNode(child, childId);
                if (foundParent) return foundParent;
            }
            return null;
        }

        function getSVGString(svgNode, bounds, padding) {
            const clone = svgNode.cloneNode(true);
            d3.select(clone).selectAll('rect.selected').classed('selected', false);
            const innerG = d3.select(clone).select('g');
            const style = document.createElement('style');
            style.textContent = Array.from(document.styleSheets)
              .map(s => {
                  try { return Array.from(s.cssRules).map(r => r.cssText).join('\n'); }
                  catch (e) { return ''; }
              }).join('\n');
            clone.insertBefore(style, clone.firstChild);
            d3.select(clone)
              .attr('width', bounds.width + padding * 2)
              .attr('height', bounds.height + padding * 2);
            innerG.attr('transform', `translate(${-bounds.x + padding}, ${-bounds.y + padding})`);
            return new XMLSerializer().serializeToString(clone);
        }

        function wrap(text, width) {
            text.each(function() {
                const textElement = d3.select(this);
                const words = textElement.text().split(/\s+/).reverse();
                textElement.text(null);
                let word, line = [], lines = [], lineHeight = 1.1;
                const tspan = textElement.append("tspan").attr("x", 0);
                while (word = words.pop()) {
                    line.push(word);
                    tspan.text(line.join(" "));
                    if (tspan.node().getComputedTextLength() > width && line.length > 1) {
                        line.pop();
                        lines.push(line.join(" "));
                        line = [word];
                    }
                }
                lines.push(line.join(" "));
                tspan.remove();
                const numLines = lines.length;
                const startYOffset = -((numLines - 1) * lineHeight) / 2;
                lines.forEach((l, i) => {
                    textElement.append("tspan")
                        .attr("x", 0)
                        .attr("dy", (i === 0 ? startYOffset : lineHeight) + "em")
                        .text(l);
                });
            });
        }
    </script>
</body>
</html>

